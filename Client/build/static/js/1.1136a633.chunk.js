(self.webpackChunkmyapp=self.webpackChunkmyapp||[]).push([[1],{5962:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>o});var i=n(2791),s=n(2230),r=n(1293),a=n.n(r),l=(n(7862),n(9402),n(8372),n(184));const o=function(){return(0,i.useEffect)((()=>{a().highlightAll()}),[]),(0,l.jsxs)("div",{className:"LinearSearch",children:[(0,l.jsx)("h2",{children:"Linear Search"}),(0,l.jsx)("p",{children:"Linear search, also known as sequential search, is a simple searching algorithm used to find a particular element in a list or array. It sequentially checks each element of the list until the desired element is found or until the end of the list is reached."}),(0,l.jsx)("h3",{children:"Algorithm:"}),(0,l.jsxs)("p",{children:[(0,l.jsx)("strong",{children:"Step-by-step explanation:"}),(0,l.jsxs)("ol",{children:[(0,l.jsxs)("li",{children:[" ",(0,l.jsx)("h4",{children:"Start at the beginning:"})," Linear search starts from the first element of the list."]}),(0,l.jsxs)("li",{children:[" ",(0,l.jsx)("h4",{children:"Compare elements:"})," It compares the target element with each element in the list sequentially."]}),(0,l.jsxs)("li",{children:[" ",(0,l.jsx)("h4",{children:"If found:"})," If the current element matches the target, the search ends, and the index of the element is returned."]}),(0,l.jsxs)("li",{children:[(0,l.jsx)("h4",{children:"If not found:"}),(0,l.jsxs)("ol",{children:[(0,l.jsx)("li",{children:"Move to the next element."}),(0,l.jsx)("li",{children:"Repeat steps 2-3 until the element is found or until the end of the list is reached."})]})]}),(0,l.jsxs)("li",{children:[(0,l.jsx)("h4",{children:"If reached the end:"})," If the search completes without finding the element, a signal (like returning -1) is used to indicate that the element is not present in the list."]})]})]}),(0,l.jsx)(s.Z,{handleLanguageChange:e=>" ".concat(e),cLangElements:["#include <stdio.h>","int main() {","    int arr[] = {2, 5, 8, 10, 13, 18, 23};","    int target = 13;","    int size = sizeof(arr) / sizeof(arr[0]);","    int result = linearSearch(arr, size, target);","    if (result != -1) {",'        printf("Element found at index: %d\\n", result);',"    } else {",'        printf("Element not found in the array\\n");',"    }","    return 0;","}","int linearSearch(int arr[], int size, int target) {","    for (int i = 0; i < size; i++) {","        if (arr[i] == target) {","            return i; // Return the index if found","        }","    }","    return -1; // Return -1 if not found","}"],javaLangElements:["public class LinearSearch {","    public static void main(String[] args) {","        int[] arr = {2, 5, 8, 10, 13, 18, 23};","        int target = 13;","        int size = arr.length;","        int result = linearSearch(arr, size, target);","        if (result != -1) {",'            System.out.println("Element found at index: " + result);',"        } else {",'            System.out.println("Element not found in the array");',"        }","    }","    public static int linearSearch(int[] arr, int size, int target) {","        for (int i = 0; i < size; i++) {","            if (arr[i] == target) {","                return i; // Return the index if found","            }","        }","        return -1; // Return -1 if not found","    }","}"]}),(0,l.jsx)("h3",{children:"Characteristics:"}),(0,l.jsxs)("ul",{children:[(0,l.jsx)("li",{children:"Unordered lists: Linear search can be used on both sorted and unsorted lists."}),(0,l.jsx)("li",{children:"Simple implementation: It's straightforward to understand and implement."}),(0,l.jsx)("li",{children:"Efficiency: For large lists, it's less efficient compared to other search algorithms like binary search for sorted lists."})]}),(0,l.jsx)("h3",{children:"Complexity:"}),(0,l.jsxs)("ul",{children:[(0,l.jsx)("li",{children:"Best Case: O(1) - When the element is found at the beginning."}),(0,l.jsx)("li",{children:"Average Case: O(n) - where 'n' is the number of elements in the list."}),(0,l.jsx)("li",{children:"Worst Case: O(n) - When the element is at the end of the list or not present."})]}),(0,l.jsx)("p",{children:"Linear search is suitable for small lists or situations where the list is unordered or the overhead of sorting the list for more efficient algorithms isn't worth it."})]})}},2230:(e,t,n)=>{"use strict";n.d(t,{Z:()=>l});var i=n(2791),s=n(1293),r=n.n(s),a=(n(7862),n(9402),n(184));const l=function(e){let{handleLanguageChange:t,cLangElements:n,javaLangElements:s}=e;const[l,o]=(0,i.useState)("c"),[c,d]=(0,i.useState)(""),h=()=>{const e=("c"===l?n:s).join("\n");navigator.clipboard.writeText(e).then((()=>{d("Copied..!"),setTimeout((()=>{d("")}),1e3)})).catch((()=>d("Copy Failed")))};return(0,i.useEffect)((()=>{r().highlightAll()}),[n,s]),(0,a.jsxs)("div",{className:"container",children:[(0,a.jsxs)("div",{className:"button-group",children:[(0,a.jsx)("button",{className:"btnC ".concat("c"===l?"active":""),onClick:()=>{o("c"),t("c")},children:"C"}),(0,a.jsx)("button",{className:"btnJava ".concat("java"===l?"active":""),onClick:()=>{o("java"),t("java")},children:"Java"})]}),(0,a.jsx)("div",{className:"code-section-container",children:(u="c"===l?n:s,(0,a.jsxs)("div",{className:"code-section",children:[(0,a.jsx)("div",{className:"copy-button-container",children:(0,a.jsx)("button",{className:"copy-button ".concat(c&&"copied"),onClick:h,children:c||"Copy Code"})}),(0,a.jsx)("pre",{className:"language-c",children:(0,a.jsx)("code",{className:"language-c",children:u.join("\n")})})]}))})]});var u}},8372:()=>{!function(e){var t=/\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/,n=/(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source,i={pattern:RegExp(/(^|[^\w.])/.source+n+/[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),lookbehind:!0,inside:{namespace:{pattern:/^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,inside:{punctuation:/\./}},punctuation:/\./}};e.languages.java=e.languages.extend("clike",{string:{pattern:/(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,lookbehind:!0,greedy:!0},"class-name":[i,{pattern:RegExp(/(^|[^\w.])/.source+n+/[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),lookbehind:!0,inside:i.inside},{pattern:RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source+n+/[A-Z]\w*\b/.source),lookbehind:!0,inside:i.inside}],keyword:t,function:[e.languages.clike.function,{pattern:/(::\s*)[a-z_]\w*/,lookbehind:!0}],number:/\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,operator:{pattern:/(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,lookbehind:!0},constant:/\b[A-Z][A-Z_\d]+\b/}),e.languages.insertBefore("java","string",{"triple-quoted-string":{pattern:/"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,greedy:!0,alias:"string"},char:{pattern:/'(?:\\.|[^'\\\r\n]){1,6}'/,greedy:!0}}),e.languages.insertBefore("java","class-name",{annotation:{pattern:/(^|[^.])@\w+(?:\s*\.\s*\w+)*/,lookbehind:!0,alias:"punctuation"},generics:{pattern:/<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,inside:{"class-name":i,keyword:t,punctuation:/[<>(),.:]/,operator:/[?&|]/}},import:[{pattern:RegExp(/(\bimport\s+)/.source+n+/(?:[A-Z]\w*|\*)(?=\s*;)/.source),lookbehind:!0,inside:{namespace:i.inside.namespace,punctuation:/\./,operator:/\*/,"class-name":/\w+/}},{pattern:RegExp(/(\bimport\s+static\s+)/.source+n+/(?:\w+|\*)(?=\s*;)/.source),lookbehind:!0,alias:"static",inside:{namespace:i.inside.namespace,static:/\b\w+$/,punctuation:/\./,operator:/\*/,"class-name":/\w+/}}],namespace:{pattern:RegExp(/(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g,(function(){return t.source}))),lookbehind:!0,inside:{punctuation:/\./}}})}(Prism)}}]);
//# sourceMappingURL=1.1136a633.chunk.js.map